---
#
# Copyright (c) 2019 Wind River Systems, Inc.
#
# SPDX-License-Identifier: Apache-2.0
#
# ROLE DESCRIPTION:
#   This role is to validate amd save host (non secure) config.
#

- debug: 
    msg: >
           System mode is {{ system_mode }},
           Timezone is {{ timezone }},
           Virtual switch type is {{ vswitch_type }},
           DNS servers are {{ dns_servers }},
           PXE boot subnet is {{ pxeboot_subnet }},
           Management subnet is {{ management_subnet }},
           Cluster subnet is {{ cluster_subnet }},
           OAM subnet is {{ external_oam_subnet }},
           OAM gateway is {{ external_oam_gateway_address }},
           OAM floating ip is {{ external_oam_floating_address }},
           Dynamic address allocation is {{ dynamic_address_allocation }},
           Docker HTTP proxy is {{ docker_http_proxy }},
           Docker HTTPS proxy is {{ docker_https_proxy }},
           Docker no proxy list is {{ docker_no_proxy }}


# System parameters config validation
- block:
  - name: Set system mode and vswitch type facts
    set_fact:
      system_mode: "{{ system_mode|lower }}"
      vswitch_type: "{{ vswitch_type|lower }}"

  - name: Validate system mode
    fail:
      msg: "Invalid system mode. Valid values are: simplex, duplex or duplex-direct."
    when: >
      system_mode != 'simplex' and
      system_mode != 'duplex' and
      system_mode != 'duplex-direct'

  - name: Validate vswitch type
    fail:
      msg: "Invalid vswitch type. Valid values are: ovs-dpdk or avs."
    when: vswitch_type != 'ovs-dpdk' and vswitch_type != 'avs'

  - name: Checking registered timezones
    stat:
      path: "{{ '/usr/share/zoneinfo/' + timezone }}"
    register: timezone_file

  - name: Fail if provided timezone is unknown
    fail: msg="The provided timezone {{ timezone }} is invalid."
    when: not timezone_file.stat.exists

  - name: Fail if the number of dns servers provided is not at least 1 and no more than 3
    fail:
      msg: "The number of DNS servers exceeds maximum allowable number of 3."
    when: (dns_servers | length == 0) or (dns_servers | length > 3)


# DNS servers config validation
- block:
  # Looping over a block of tasks is not yet supported. For now, move the
  # DNS validation to a seprate tasks file.
  - include: validate_dns.yml dns_server={{ item }}
    with_items: "{{ dns_servers }}"


# Networks config validation
- block:
  - name: Validate provided subnets (both IPv4 & IPv6 notations)
    debug:
      msg: "{{ item.key }}: {{ item.value }}"
    failed_when: item.value|ipaddr == False
    with_dict: "{{ network_params }}"

  - name: Set management subnet size fact
    set_fact:
      mgmt_network_size: "{{ network_params.management_subnet|ipaddr('size') }}"

  - name: Fail if management subnet size is too small
    fail:
      msg: "Subnet too small, must have {{ minimum_size }} addresses"
    when: mgmt_network_size|int < minimum_address_size

  - set_fact:
      ipv6_addressing: "{{ network_params.management_subnet|ipv6 }}"

  - block:
    - name: Fail if IPv6 management on simplex
      fail:
        msg: "IPv6 management network not supported on simplex configuration."
      when: system_mode == 'simplex'

    - name: Fail if IPv6 prefix length is too short
      fail:
        msg: "IPv6 minimum prefix length is {{ minimum_prefix_length }}"
      when: network_params.management_subnet|ipaddr('prefix')|int < minimum_ipv6_prefix_length

    when: ipv6_addressing

  - name: Fail if address allocation is misconfigured
    fail:
      msg: "dynamic_address_allocation is misconfigured. Valid value is either 'True' or 'False'."
    when: not dynamic_address_allocation | bool 

  - name: Set derived facts for subsequent roles
      # Not sure why ipaddr('address') and ipsubnet filter did not extract the IP
      # from CIDR input. Resort to string split for now.
    set_fact:
      derived_network_params:
        'management_interface': lo
        'management_interface_name': lo
        'controller_floating_address': "{{ (management_subnet | ipaddr(2)).split('/')[0] }}"
        'controller_0_address': "{{ (management_subnet | ipaddr(3)).split('/')[0] }}"
        'controller_1_address': "{{ (management_subnet | ipaddr(4)).split('/')[0] }}"
        'nfs_management_address_1': "{{ (management_subnet | ipaddr(5)).split('/')[0] }}"
        'nfs_management_address_2': "{{ (management_subnet | ipaddr(6)).split('/')[0] }}"

        'controller_pxeboot_floating_address': "{{ (pxeboot_subnet | ipaddr(2)).split('/')[0] }}"
        'controller_pxeboot_address_0': "{{ (pxeboot_subnet | ipaddr(3)).split('/')[0] }}"
        'controller_pxeboot_address_1': "{{ (pxeboot_subnet | ipaddr(4)).split('/')[0] }}"

        'external_oam_0_address': "{{ (external_oam_subnet | ipaddr(3)).split('/')[0] }}"
        'external_oam_1_address': "{{ (external_oam_subnet | ipaddr(4)).split('/')[0] }}"

      # Make common facts available to other roles
      config_workdir: "{{ config_workdir }}"
      dns_servers: "{{ dns_servers }}"

      # Derived network parameters that don't apply to bootstrap_config but are required for
      # subsequent roles
      management_subnet_prefix: "{{ management_subnet | ipaddr('prefix') }}"
      management_broadcast: "{{ management_subnet | ipaddr('broadcast') }}"
      pxe_subnet_prefix: "{{ pxeboot_subnet | ipaddr('prefix') }}"
      cluster_subnet_prefix: "{{ cluster_subnet | ipaddr('prefix') }}"
      cluster_broadcast: "{{ cluster_subnet | ipaddr('broadcast') }}"
      cluster_floating_address: "{{ (cluster_subnet | ipaddr(2)).split('/')[0] }}"
      controller_0_cluster_host: "{{ (cluster_subnet | ipaddr(3)).split('/')[0] }}"
      controller_1_cluster_host: "{{ (cluster_subnet | ipaddr(4)).split('/')[0] }}"
      storage_0: "{{ (management_subnet | ipaddr(10)).split('/')[0] }}"


# Docker config validation
- block:
  - set_fact:
      use_default_registries: true
      # Define these just in case we need them later
      default_k8s_registry: k8s.gcr.io
      default_gcr_registry: gcr.io
      default_quay_registry: quay.io
      default_docker_registry: docker.io
      default_no_proxy:
        - localhost
        - 127.0.0.1
        - "{{ derived_network_params.controller_floating_address }}"
        - "{{ derived_network_params.controller_0_address }}"
        - "{{ derived_network_params.controller_1_address }}"
      sx_proxy_addons:
        - "{{ derived_network_params.external_oam_0_address }}"
      non_sx_proxy_addons:
        - "{{ external_oam_floating_address }},"
        - "{{ derived_network_params.external_oam_0_address }},"
        - "{{ derived_network_params.external_oam_1_address }}"
      docker_no_proxy_combined: []

  - block:
    - name: Set default no-proxy address list (simplex)
      set_fact:
        default_no_proxy: "{{ default_no_proxy + sx_proxy_addons }}"
      when: system_mode == 'simplex'

    - name: Set default no-proxy address list (non simplex)
      set_fact:
        default_no_proxy: "{{ default_no_proxy + non_sx_proxy_addons }}"
      when: system_mode != 'simplex'

    - block:
      - name: Validate http proxy urls
        include: validate_url.yml input_url={{ item }}
        with_items:
          - "{{ docker_http_proxy }}"
          - "{{ docker_https_proxy }}"

    - block:
      - name: Validate no proxy addresses
        include: validate_address.yml input_address={{ item }}
        with_items: "{{ docker_no_proxy }}"
        when: docker_no_proxy|length > 0

    - name: Add user defined no-proxy address list to default
      set_fact:
        docker_no_proxy_combined: "{{ default_no_proxy + docker_no_proxy }}"

    when: use_docker_proxy

  - block:
    - name: Fail if secure registry flag is misconfigured
      fail:
        msg: "is_secure_registry is misconfigured. Valid value is either 'True' or 'False'."
      when: (is_secure_registry is defined) and
            (not is_secure_registry | bool)

    - name: Default the unified registry to secure if not specified
      set_fact:
        is_secure_registry: True
      when: is_secure_registry is not defined

    - name: Turn on use_unified_registry flag
      set_fact:
        use_unified_registry: true
        unified_registry: "{{ docker_registries }}"

    when: docker_registries|length == 1

  - name: Update use_default_registries flag
    set_fact:
      use_default_registries: false
    when: use_unified_registry or
          docker_registries|length != 4 or
          default_k8s_registry not in docker_registries or
          default_gcr_registry not in docker_registries or
          default_quay_registry not in docker_registries or
          default_docker_registry not in docker_registries

  - block:
    - include: validate_address.yml  input_address={{ item }}
      with_items: "{{ docker_registries }}"
    when: not use_default_registries


# Docker images archive source validation
- block:
  - set_fact:
      images_archive_exists: false

  - block:
    - name: Check if images archive location exists
      stat:
        path: "{{ docker_images_archive_source }}"
      register: archive_source

    - block:
      - name: Get list of archived files
        find:
          paths: "{{ docker_images_archive_source }}"
          patterns: "*.tar"
        register: archive_find_output

      - name: Turn on images archive flag
        set_fact:
          images_archive_exists: true
        when: archive_find_output.matched > 0

      when: archive_source.stat.exists
    delegate_to: localhost
    when: (docker_images_archive_source is defined) and
          (docker_images_archive_source is not none)


# bootstrap_config ini file generation
- block:
  - name: Create config workdir
    file:
      path: "{{ config_workdir }}"
      state: directory
      owner: root
      group: root
      mode: 0755

  - name: Generate config ini file for python sysinv db population script
    lineinfile:
      path: "{{ bootstrap_config_file }}"
      line: "{{ item }}"
      create: yes
    with_items:
      - "[BOOTSTRAP_CONFIG]"
      - "CONTROLLER_HOSTNAME=controller-0"
      - "SYSTEM_TYPE={{ system_type }}"
      - "SYSTEM_MODE={{ system_mode }}"
      - "TIMEZONE={{ timezone }}"
      - "VSWITCH_TYPE={{ vswitch_type }}"
      - "SW_VERSION={{ software_version }}"
      - "NAMESERVERS={{ dns_servers| join(',') }}"
      - "PXEBOOT_SUBNET={{ pxeboot_subnet }}"
      - "MANAGEMENT_SUBNET={{ management_subnet }}"
      - "DYNAMIC_ADDRESS_ALLOCATION={{ dynamic_address_allocation }}"
      - "MANAGEMENT_INTERFACE=lo"
      - "CONTROLLER_0_ADDRESS={{ derived_network_params.controller_0_address }}"
      - "CLUSTER_SUBNET={{ cluster_subnet }}"
      - "EXTERNAL_OAM_SUBNET={{ external_oam_subnet }}"
      - "EXTERNAL_OAM_GATEWAY_ADDRESS={{ external_oam_gateway_address }}"
      - "EXTERNAL_OAM_FLOATING_ADDRESS={{ external_oam_floating_address }}"
      - "EXTERNAL_OAM_1_ADDRESS={{ derived_network_params.external_oam_1_address }}"
      - "MANAGEMENT_MULTICAST_SUBNET={{ management_multicast_subnet }}"
      - "DOCKER_HTTP_PROXY={{ docker_http_proxy }}"
      - "DOCKER_HTTPS_PROXY={{ docker_https_proxy }}"
      - "DOCKER_NO_PROXY={{ docker_no_proxy_combined | join(',') }}"
      - "DOCKER_REGISTRIES={{ docker_registries | join(',') }}"
      - "USE_DEFAULT_REGISTRIES={{ use_default_registries }}"
      - "IS_SECURE_REGISTRY={{ is_secure_registry | default(True) }}"

  - name: Write simplex flag
    file:
      path: /etc/platform/simplex
      state: touch

  when: save_config
